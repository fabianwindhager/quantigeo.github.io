[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantitative Geographie: Mobile Gesellschaft",
    "section": "",
    "text": "Willkommen zum Kurs “Quantitative Geographie” (Universität Innsbruck SoSe 2026).\nAuf dieser Website finden sie das Kursmaterial zu den R-Inhalten.\n\nLiteratur\nWickham, H., Cetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science : import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media, Incorporated.\nLiao, T. F., Bolano, D., Brzinsky-Fay, C., Cornwell, B., Fasang, A. E., Helske, S., Piccarreta, R., Raab, M., Ritschard, G., Struffolino, E., & Studer, M. (2022). Sequence analysis: Its past, present, and future. Social Science Research, 107, 102772. https://doi.org/10.1016/j.ssresearch.2022.102772\nGabadinho, A., Ritschard, G., Müller, N. S., & Studer, M. (2011). Analyzing and Visualizing State Sequences in R with TraMineR. Journal of Statistical Software, 40(4). https://doi.org/10.18637/jss.v040.i04{r} 1 + 1",
    "crumbs": [
      "Intro"
    ]
  },
  {
    "objectID": "04_mapping.html",
    "href": "04_mapping.html",
    "title": "Skript 4 - Spatial Data Frames & Mapping",
    "section": "",
    "text": "Mit dem Paket “sf” (“Spatial Features”) kann R auch als Geoinformationssystem verwendet werden. Das Paket “mapview” ermöglicht das einfache Erstellen von interaktiven Karten. Wir installieren beide Pakete mit install.packages() und laden sie mit library()\nUm Karten zu erstellen müssen wir unserem Dataframe räumliche Informationen hinzufügen. Die Statistik Austria stellt zu diesem Zweck in ihrem STATatlas die regionale Gliederung Österreichs in Form von .shp files zur Verfügung.\nEin Shapefile ist ein älteres, sehr verbreitetes Dateiformat, mit dem man Kartenobjekte wie Punkte, Linien und Flächen samt ihren Daten speichert. Es besteht aus mehreren zusammengehörigen Dateien (z. B. .shp, .shx, .dbf), die gemeinsam in einem Ordner liegen müssen, und wird von den meisten GIS‑Programmen unterstützt.\nWir nutzen das Package sf um Geodaten einzulesen -&gt; read_sf()\nNach dem Import erhalten wir Informationen zur Kartenprojektion, dem Geoemtrietyp und dem betreffenden Kartenausschnitt.\n\nshp &lt;- read_sf(\"data/OGDEXT_GEM_1_STATISTIK_AUSTRIA_20250101/STATISTIK_AUSTRIA_GEM_20250101.shp\")   \nhead(shp) # in der Spalte geometry sind die Koordinaten (Punkte, Polygone, Linien) für jede Gemeinde in Österreich gespeichert\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 628026.2 ymin: 436909.1 xmax: 659390.5 ymax: 458158.4\nProjected CRS: MGI / Austria Lambert\n# A tibble: 6 × 3\n  g_id  g_name                                                          geometry\n  &lt;chr&gt; &lt;chr&gt;                                                 &lt;MULTIPOLYGON [m]&gt;\n1 10101 Eisenstadt                     (((637377.1 439927.1, 637314.8 439990.3,…\n2 10201 Rust                           (((649519.4 441308.4, 649519.1 441303.2,…\n3 10301 Breitenbrunn am Neusiedler See (((651390.8 458137, 651422.4 458098.8, 6…\n4 10302 Donnerskirchen                 (((657709.2 448462, 657306.5 448432.9, 6…\n5 10303 Großhöflein                    (((635649.5 445523.9, 635660.6 445491.5,…\n6 10304 Hornstein                      (((634388.3 450387.4, 634474.4 450373.2,…\n\n\n\nshp$g_id &lt;- as.integer(shp$g_id)\nmap &lt;- left_join(seq, shp, by = c(\"gemnr\" = \"g_id\")) %&gt;% \n  st_as_sf()\n\nmap$Wert &lt;- as.factor(map$Wert)\nmap$cluster.dhd &lt;- as.factor(map$cluster.dhd)\n\n## Recoding map$Wert into map$typ\nmap$typ &lt;- map$Wert %&gt;%\n  fct_recode(\n    \"Urbane Großzentren\" = \"101\",\n    \"Urbane Mittelzentren\" = \"102\",\n    \"Urbane Kleinzentren\" = \"103\",\n    \"Regionale Zentren, zentral\" = \"210\",\n    \"Regionale Zentren, intermediär\" = \"220\",\n    \"Ländlicher Raum im Umland von Zentren, zentral\" = \"310\",\n    \"Ländlicher Raum im Umland von Zentren, intermediär\" = \"320\",\n    \"Ländlicher Raum im Umland von Zentren, peripher\" = \"330\",\n    \"Ländlicher Raum, zentral\" = \"410\",\n    \"Ländlicher Raum, intermediär\" = \"420\",\n    \"Ländlicher Raum, peripher\" = \"430\"\n  )\n\nlibrary(patchwork)\nmap_cluster &lt;- ggplot(data = map) +\n  geom_sf(aes(fill = cluster.dhd))+\n  scale_fill_brewer(palette = \"Accent\")+\n  theme_classic()\n\nmap_typ &lt;- ggplot(data = map) +\n  geom_sf(aes(fill = typ), color = NA) +\n  scale_fill_manual(\n    values = c(\n      \"Urbane Großzentren\" = \"#b35e6b\",\n      \"Urbane Mittelzentren\" = \"#d67169\",\n      \"Urbane Kleinzentren\" = \"#e08f81\",\n      \"Regionale Zentren, zentral\" = \"#eeaf58\",\n      \"Regionale Zentren, intermediär\" = \"#f5ca82\",\n      \"Ländlicher Raum im Umland von Zentren, zentral\" = \"#fdf453\",\n      \"Ländlicher Raum im Umland von Zentren, intermediär\" = \"#fefabb\",\n      \"Ländlicher Raum im Umland von Zentren, peripher\" = \"#eeec85\",\n      \"Ländlicher Raum, zentral\" = \"#c2d38c\",\n      \"Ländlicher Raum, intermediär\" = \"#84b870\",\n      \"Ländlicher Raum, peripher\" = \"#789d6e\"\n    )\n  ) +\n  theme_classic()\n\nmap_typ / map_cluster",
    "crumbs": [
      "Skript 4 - Spatial Data Frames & Mapping"
    ]
  },
  {
    "objectID": "02_data_manipulation.html",
    "href": "02_data_manipulation.html",
    "title": "Skript 2 - Daten import, manipulation & plotten",
    "section": "",
    "text": "2.1. Daten importieren\nIm Kurs “Quantitative Geographien” arbeiten wir mit .csv und .shp files.\nZuerst importieren wir einen Datensatz mit den jährlichen Bevölkerungszahlen im Jahresmittel von 2002-2023. (bereitgestellt auf Lernplattform)\n\n# Import Bevölkerungsdaten\npop &lt;- read.csv(\"data/Bevölkerungsdaten.csv\")\n\n# Import Wanderungsdaten\nmoves &lt;- read.csv(\"data/Wanderungsdaten.csv\")\n\nUm einen ersten Überblick über die Datensätze zu erhalten, können wir die Funktionen head() und str() verwenden.\n\nhead(pop)\n\n  jahr gemnr   pop\n1 2002 10101 11644\n2 2003 10101 11699\n3 2004 10101 11799\n4 2005 10101 12045\n5 2006 10101 12171\n6 2007 10101 12350\n\nstr(pop)\n\n'data.frame':   50736 obs. of  3 variables:\n $ jahr : int  2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 ...\n $ gemnr: int  10101 10101 10101 10101 10101 10101 10101 10101 10101 10101 ...\n $ pop  : int  11644 11699 11799 12045 12171 12350 12549 12717 12816 12950 ...\n\nnames(pop)\n\n[1] \"jahr\"  \"gemnr\" \"pop\"  \n\nhead(moves)\n\n  gemnr jahr bi_zu bi_weg au_zu au_weg\n1 10101 2002   870    763    92    127\n2 10101 2003  1192   1120   145    101\n3 10101 2004  1294   1088   141    122\n4 10101 2005  1121   1027   134     81\n5 10101 2006  1304   1112   116    123\n6 10101 2007  1363   1210   224    163\n\nstr(moves)\n\n'data.frame':   46497 obs. of  6 variables:\n $ gemnr : int  10101 10101 10101 10101 10101 10101 10101 10101 10101 10101 ...\n $ jahr  : int  2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 ...\n $ bi_zu : int  870 1192 1294 1121 1304 1363 1354 1297 1235 1338 ...\n $ bi_weg: int  763 1120 1088 1027 1112 1210 1173 1227 1160 1234 ...\n $ au_zu : int  92 145 141 134 116 224 259 282 288 313 ...\n $ au_weg: int  127 101 122 81 123 163 260 226 208 245 ...\n\nnames(moves)\n\n[1] \"gemnr\"  \"jahr\"   \"bi_zu\"  \"bi_weg\" \"au_zu\"  \"au_weg\"\n\n\n\n\n2.2. The pipe operator %&gt;%\nDer Pipe-Operator %&gt;% (Strg + Umschalt + M) übergibt das Ergebnis einer Funktion an die nächste.\n\npop %&gt;% \n  filter(gemnr == 10101) %&gt;% \n  pull(pop) %&gt;% \n  mean()\n\n[1] 13619.38\n\n\nDie Pipe kann man lesen als „UND DANN“. Daten nehmen, UND DANN filtern, UND DANN Bevölkerungszahlen ziehen, UND DANN Mittelwert nehmen.\n\n\n2.3. Filter & Select\nDie Datenbereinigung macht 80 % der Arbeit aus. dplyr bietet fünf wichtige Funktionen. Die ersten beiden reduzieren die Datengröße.\nMit filter() behält man nur Zeilen, die einer Bedingung entsprechen.\n\n# filter()\npop_2002 &lt;- pop %&gt;% \n  filter(jahr == 2002)\n\n\n\n\n\n\n\n\nLogical Operators\n\n\n\n\n\n==\nist gleich (Beachte das doppelte Gleichheitszeichen!)\n\n\n!=\nist ungleich\n\n\n&\nUND (Beide/Alle Bedingungen müssen erfüllt sein)\n\n\n|\nODER (Mindestens eine Bedingung muss erfüllt sein)\n\n\n%in%\nWert befindet sich in einer Liste\n\n\n\nMit select() behält man nur bestimmte Spalten bei. Nützlich, um Datensätze mit vielen Spalten zu bereinigen.\n\nkennz &lt;- pop_2002 %&gt;% \n  select(gemnr)\n\nhead(kennz)\n\n  gemnr\n1 10101\n2 10201\n3 10301\n4 10302\n5 10303\n6 10304\n\n\n\n\n2.4. Mutate\nOftmals müssen Sie aus alten Daten neue Daten erstellen. In unserem Fall möchten wir beispielsweise Migrationssalden berechnen. mutate() fügt dem Dataframe eine neue Spalte mit der gewünschten Berechnung hinzu.\nWir berechnen zuerst das Binnenmigrationssaldo (bi_saldo) und dann das Aussenwanderungssaldo (au_saldo) für alle Gemeinden in Österreich.\n\nmoves &lt;- moves %&gt;% \n  mutate(bi_saldo = bi_zu - bi_weg,\n         au_saldo = au_zu - au_weg)\n\n\n\n2.5. Joins\nDa wir in sowohl in “moves” als auch in “pop” die gleichen Gemeindekennziffern haben, können wir die beiden dataframes vereinigen (oder “joinen”). Zuvor müssen wir allerdings die Jahre 2024 und 2025 aus dem “pop” datensatz entfernen.\n\npop &lt;- pop %&gt;% \n  filter(!jahr %in% c(2024, 2025))\n\nWir joinen die beiden Datensätze anhand der Variablen gemnr und jahr.\nDer Code verbindet die beiden Tabellen pop und moves anhand der Spalten (by) gemnr und jahr, sodass alle Daten aus pop beibehalten und die passenden Werte aus moves ergänzt werden.\n\ndta &lt;- left_join(pop, moves, by = c(\"gemnr\", \"jahr\"))\n\nDie erste Zahl der Gemeindekennziffern (“gemnr”) gibt das betreffende Bundesland an. Alle Gemeindekennziffern die mit “7” beginnen, sind demnach Tiroler Gemeinden.\n\ndta &lt;- dta %&gt;%\n  mutate(bld = str_sub(gemnr, 1, 1))\n\n# Wir ersetzen NAs mit 0 (Manche Gemeinden erfahren keine Zu- oder Abwanderung in einzelnen Jahren)\ndta[is.na(dta)] &lt;- 0\n\nwrite.csv(dta, \"data/Gemeindedaten.csv\", row.names = FALSE)\n\nNun haben wir einen Datensatz mit dem wir weitere Berechnungen anstellen können!\n\n\n2.6. Group By & Summarize\ngroup_by() teilt die Daten in Gruppen nach einer oder mehreren Variablen, und summarize() berechnet dann zusammenfassende Kennzahlen (wie Summe oder Mittelwert) für jede Gruppe.\nHier berechnen wir Gesamtbevölkerungszahlen und Migrationssalden (Innen- und Aussenwanderungen) für jedes Bundesland, in dem wir die Gemeindezahlen zusammenfassen.\n\nbld_dta &lt;- dta %&gt;% \n  group_by(bld, jahr) %&gt;% \n  summarise(pop_tot = sum(pop),\n            bi_saldo_tot = sum(bi_saldo),\n            au_saldo_tot = sum(au_saldo)) %&gt;% \n  ungroup()\n\n`summarise()` has grouped output by 'bld'. You can override using the `.groups`\nargument.\n\nhead(bld_dta)\n\n# A tibble: 6 × 5\n  bld    jahr pop_tot bi_saldo_tot au_saldo_tot\n  &lt;chr&gt; &lt;int&gt;   &lt;int&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1 1      2002  276673          120          523\n2 1      2003  276542          302          723\n3 1      2004  276792          807         1096\n4 1      2005  278032          931          886\n5 1      2006  279127         1129          753\n6 1      2007  280062         1138          625\n\n\nWir berechnen je eine neue Spalte (mutate) mit den:\n\nBevölkerungsveränderungsrate\nDie Bevölkerungsveränderungsrate ist definiert als \\[\\frac{Bevölkerungsstand_t - Bevölkerungsstand_{t-1}}{Bevölkerungsstand_{t-1}} \\times 100\\].\nAbsolute Veränderung = Differenz zwischen zwei Jahren (pop_diff) Rate = Differenz relativ zur Ausgangsbevölkerung (pop_rate)\nDie Bevölkerungsveränderungsrate gibt an, um wie viel Prozent sich die Bevölkerung eines Gebietes innerhalb eines bestimmten Zeitraums verändert hat.\n\n\n\nBinnenwanderungsrate\nDie Binnenwanderungsrate berechnet sich als \\[\\frac{\\text{Binnenwanderungssaldo}}{\\text{Bevölkerungsstand}} \\times 1000\\].\nDie Rate gibt an, wie viele Personen pro 1.000 Einwohner:innen durch Binnenmigration gewonnen oder verloren werden\nAussenwanderungsrate\nDie Außenwanderungsrate berechnet sich als \\[\\frac{\\text{Außenwanderungssaldo}}{\\text{Bevölkerungsstand}} \\times 1000\\].\nDie Außenwanderungsrate zeigt, wie viele Personen pro 1.000 Einwohner:innen durch Zu- und Wegzüge über die Staatsgrenze hinweg gewonnen oder verloren werden.\nGesamtmigrationsbilanz\nDie Gesamtmigrationsbilanz berechnet sich als \\[\\text{Binnenwanderungssaldo} + \\text{Außenwanderungssaldo}\\].\nDie Gesamtmigrationsbilanz zeigt den gesamten Bevölkerungsgewinn oder -verlust einer Region durch alle Wanderungsbewegungen.\nDie Gesamtmigrationsrate berechnet sich analog zu den anderen Migrationsraten als \\[\\frac{\\text{Gesamtmigrationssaldo}}{\\text{Bevölkerungsstand}} \\times 1000\\].\nNatürliche Bevölkerungsveränderung\nSieht man sich die demographische Gesamtrechnung an:\n\\[ \\Delta \\text{Bevölkerungsveränderung} = \\underbrace{\\text{natürliche Veränderung}}_{\\text{Geburten - Sterbefälle}} + \\underbrace{\\text{Binnenwanderungssaldo}}_{\\text{Zu- minus Fortzüge innerhalb des Landes}} + \\underbrace{\\text{Außenwanderungssaldo}}_{\\text{Zu- minus Fortzüge über die Staatsgrenze}} \\]\nmüssten wir theoretisch die natürliche Bevölkerungsveränderung mit \\(\\text{Bevölkerungsveränderung} - \\text{Gesamtmigrationssaldo}\\). berechnen können.\nABER ACHTUNG:\nDie auf diese Art berechneten natürlichen Bevölkerungszahlen können von offiziellen Statistiken abweichen, weil unsere Bevölkerungsstände zum Stichtag 1.1. erfasst werden, während Migrationsdaten über das Jahr verteilt für den Referenzzeitraum erhoben werden!\n\nDie Funktion lag() verschiebt die Werte einer Variable um eine Position nach unten, sodass man den vorherigen Wert einer Beobachtung mit dem aktuellen vergleichen kann (z. B. für Zeitreihen, Differenzen oder eben das Berechnen von relativen Veränderungen).\n\nbld_dta &lt;- bld_dta %&gt;% \n  group_by(bld) %&gt;% \n  mutate(pop_diff = pop_tot - lag(pop_tot),\n         pop_rate = (pop_diff / lag(pop_tot)) * 100,\n         bi_rate = (bi_saldo_tot / pop_tot) * 1000,\n         au_rate = (au_saldo_tot / pop_tot) * 1000,\n         mig_saldo = au_saldo_tot + bi_saldo_tot,\n         mig_rate = (mig_saldo / pop_tot) * 1000,\n         nat_change = (pop_tot - lag(pop_tot) - lag(mig_saldo))) %&gt;% \n  ungroup()\n\n\n\n2.7. The Grammar of Graphics\nggplot2 basiert auf Ebenen. Man erstellt nicht einfach „ein Diagramm“, sondern baut es Schicht für Schicht auf, wie einen Kuchen. Die wesentlichsten Funktionen von ggplot finden sich unter\nHelp-&gt;Cheat Sheets-&gt;Data Visualistion with ggplot\nDie 3 wesentlichen Schichten:\n\nData: Der Datenframe den man plotten möchte.\nAesthetics (aes): Zuordnung von Variablen zu visuellen Eigenschaften (X-Achse, Y-Achse, Farbe, Größe)\nGeometries (geom): Die zu zeichnende Form (oder “Art”; Bar, Point, Line)\n\nDas Plus Zeichen+ : In ggplot verwenden wir + zum Hinzufügen von Ebenen, nicht die Pipe %&gt;%. So können Sie ganz einfach Titel, Themen und Skalen hinzufügen.\nMit geom_line() erstellen wir einen Line-Chart.\n\npop_tirol &lt;- bld_dta %&gt;% \n  filter(bld == 7) %&gt;% \n  drop_na()\n\nggplot(data = pop_tirol, aes(x = jahr, y = pop_rate))+ \n  geom_col()\n\n\n\n\n\n\n\n# Wir können mit labs() die Labels der x- und y- Axe anpassen\nggplot(data = pop_tirol, aes(x = jahr, y = pop_rate))+ \n  geom_col()+\n  labs(x = \" \", y = \"Bevölkerungsveränderung in %\")\n\n\n\n\n\n\n\n# Wir können ein vorgefertigtes Thema mit beispielsweise theme_classic() auswählen\nggplot(data = pop_tirol, aes(x = jahr, y = pop_rate))+ \n  geom_col()+\n  theme_classic()+\n  labs(x = \" \", y = \"Bevölkerungsveränderung in %\")\n\n\n\n\n\n\n\n# mit \"fill\" können wir die Farbe der Balken ändern (auch mit Farbcodes möglich!)\nggplot(data = pop_tirol, aes(x = jahr, y = pop_rate))+ \n  geom_col(fill = \"dodgerblue\")+\n  theme_classic()+\n  labs(x = \" \", y = \"Bevölkerungsveränderung in %\")\n\n\n\n\n\n\n\n# Mittels zb. as.factor() können wir in ggplot den Datentyp angeben, ohne den ursprünglichen Dataframe zu ändern.\n# Mit theme() können wir jedes Element des Diagramms ansteuern und verändern\nggplot(data = pop_tirol, aes(x = as.factor(jahr), y = pop_rate))+ \n  geom_col(fill = \"firebrick\")+\n  theme_classic()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n  labs(x = \" \", y = \"Bevölkerungsveränderung in %\", title = \"Bevölkerungsveränderungrate in %; Tirol 2003-2023\")\n\n\n\n\n\n\n\n\nMit geom_col() erstellen wir einen Bar-Chart. Mit theme_classic() können wir das Thema des Plots ändern.\n\nggplot(data = pop_tirol, aes(x = jahr, y = au_saldo_tot))+ \n  geom_col()+\n  theme_classic()+\n  labs(x = \" \", y = \"Bevölkerungsveränderung absolut\", title = \"Bevölkerungsveränderung Tirol, 2002-2023\")\n\n\n\n\n\n\n\nggplot(data = pop_tirol, aes(x = jahr, y = bi_saldo_tot))+ \n  geom_col()+\n  theme_classic()+\n  labs(x = \" \", y = \"Binnenwanderungssaldo\", title = \"Binnenwanderungssaldo Tirol, 2002-2023\")\n\n\n\n\n\n\n\nggplot(data = pop_tirol, aes(x = jahr, y = au_saldo_tot))+ \n  geom_col()+\n  theme_classic()+\n  labs(x = \" \", y = \"Aussenwanderungssaldo\", title = \"Aussenwanderungssaldo Tirol, 2002-2023\")\n\n\n\n\n\n\n\nggplot(data = pop_tirol, aes(x = jahr, y = mig_saldo))+ \n  geom_col()+\n  theme_classic()+\n  labs(x = \" \", y = \"Gesamtmigrationssaldo\", title = \"Gesamtmigrationssaldo Tirol, 2002-2023\")\n\n\n\n\n\n\n\n\n\n\n2.8. Tidy-Data\nDas Long-Format (oder “Tidy Data”) ist ein Datenformat, bei dem jede Variable eine Spalte, jede Beobachtung eine Zeile und jede Einheit eine Tabelle bildet, sodass Daten klar strukturiert und einfach analysierbar sind.\nIm Wide-Format hat jede Variable eigene Spalten, oft mit mehreren Messzeitpunkten pro Spalte, während im Long-Format jede Zeile eine einzelne Beobachtung enthält und Messzeitpunkte oder Kategorien in einer eigenen Spalte stehen.\n\n\nbld_dta_long &lt;- bld_dta %&gt;% \n  drop_na()\n\n## Recoding bld_dta$bld into bld_dta$bld_rec\nbld_dta$bld &lt;- bld_dta$bld %&gt;%\n  fct_recode(\n    \"Burgenland\" = \"1\",\n    \"Kärnten\" = \"2\",\n    \"Niederösterreich\" = \"3\",\n    \"Oberösterreich\" = \"4\",\n    \"Salzburg\" = \"5\",\n    \"Steiermark\" = \"6\",\n    \"Tirol\" = \"7\",\n    \"Vorarlberg\" = \"8\",\n    \"Wien\" = \"9\"\n  )\n\nrates_all &lt;- bld_dta %&gt;% \n  select(jahr, bld, bi_rate, au_rate, mig_rate)\n\n\nrates_all &lt;- rates_all %&gt;% \n  pivot_longer(cols = c(bi_rate, au_rate, mig_rate),\n               names_to = \"variable\",\n               values_to = \"value\")  \n\n\nggplot(data = rates_all %&gt;% filter(bld == \"Tirol\"), aes(x = as.factor(jahr), y = value, col = variable, group = variable))+\n  geom_line(linewidth = 1)+\n  theme_classic()+\n  scale_color_manual(\n  values = c(\"au_rate\" = \"dodgerblue\",  \n             \"bi_rate\" = \"firebrick\",   \n             \"mig_rate\" = \"forestgreen\"),\n  labels = c(\"Aussenwanderungsrate\", \"Binnenwanderungsrate\", \"Gesamtwanderungsrate\")\n)+\n  geom_hline(yintercept = 0, col = \"black\", linetype = \"dashed\")+\n  labs(y = \"Rate pro 1000 EW\", x = \" \", col = \" \", title = \"Migrationsstatistik Tirol, 2003-2023\", caption = \"Quelle: Statistik Austria\")+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))  \n\n\n\n\n\n\n\nggplot(data = rates_all %&gt;% filter(bld == \"Tirol\"), aes(x = as.factor(jahr), y = value, col = variable, group = variable))+\n  geom_smooth(linewidth = 1, se= F, span = 0.3)+\n  theme_classic()+\n  scale_color_manual(\n  values = c(\"au_rate\" = \"dodgerblue\",  \n             \"bi_rate\" = \"firebrick\",   \n             \"mig_rate\" = \"forestgreen\"), \n  labels = c(\"Aussenwanderungsrate\", \"Binnenwanderungsrate\", \"Gesamtwanderungsrate\")\n)+\n  geom_hline(yintercept = 0, col = \"black\", linetype = \"dashed\")+\n  labs(y = \"Rate pro 1000 EW\", x = \" \", col = \" \", title = \"Migrationsstatistik Tirol, 2003-2023\", caption = \"Quelle: Statistik Austria\")+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\nggplot(data = rates_all %&gt;% filter(bld == \"Tirol\"), aes(x = as.factor(jahr), y = value, fill = variable, group = variable))+\n  geom_col()+\n  theme_classic()+\n  scale_fill_manual(\n  values = c(\"au_rate\" = \"dodgerblue\",  \n             \"bi_rate\" = \"firebrick\",   \n             \"mig_rate\" = \"forestgreen\"), \n  labels = c(\"Aussenwanderungsrate\", \"Binnenwanderungsrate\", \"Gesamtwanderungsrate\")\n)+\n  geom_hline(yintercept = 0, col = \"black\", linetype = \"dashed\")+\n  labs(y = \"Rate pro 1000 EW\", x = \" \", fill = \" \", title = \"Migrationsstatistik Tirol, 2003-2023\", caption = \"Quelle: Statistik Austria\")+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Diese Darstellung ist fehlerhaft, warum?\n\n\n\n\n\n\n\nggplot(data = rates_all %&gt;% filter(bld == \"Tirol\"), aes(x = as.factor(jahr), y = value, fill = variable, group = variable))+\n  geom_col(position = \"dodge\")+\n  theme_classic()+\n  scale_fill_manual(\n  values = c(\"au_rate\" = \"dodgerblue\",  \n             \"bi_rate\" = \"firebrick\",   \n             \"mig_rate\" = \"forestgreen\"), \n  labels = c(\"Aussenwanderungsrate\", \"Binnenwanderungsrate\", \"Gesamtwanderungsrate\")\n)+\n  geom_hline(yintercept = 0, col = \"black\", linetype = \"dashed\")+\n  labs(y = \"Rate pro 1000 EW\", x = \" \", fill = \" \", title = \"Migrationsstatistik Tirol, 2003-2023\", caption = \"Quelle: Statistik Austria\")+\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\nMit facet_wrap() oder facet_grid() können wir diese Darstellung auch für alle Bundesländer in einem Plot vergleichend darstellen.\n\nggplot(data = rates_all %&gt;% filter(variable != \"mig_rate\"),\n       aes(x = as.factor(jahr), y = value, fill = variable, group = variable))+\n  geom_col()+\n  #theme_classic()+\n  scale_fill_manual(\n    values = c(\"au_rate\" = \"dodgerblue\",  \n               \"bi_rate\" = \"firebrick\"),\n    labels = c(\"Aussenwanderungsrate\", \"Binnenwanderungsrate\")\n  )+\n  facet_wrap(bld~.)+\n  geom_hline(yintercept = 0, col = \"black\", linetype = \"dashed\")+\n  labs(y = \"Rate pro 1000 EW\", x = \" \", fill = \" \",\n       title = \"Migrationsstatistik Österreichischer Bundesländer, 2003-2023\",\n       caption = \"Quelle: Statistik Austria\")+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\n2.9. Raumtypologien\nDie Urban-Rural-Typologie der Statistik Austria ist eine räumliche Klassifikation, die Gemeinden bzw. Regionen anhand von Kriterien wie Bevölkerungsdichte, strukturellen Merkmalen und Erreichbarkeit in städtische, intermediäre und ländliche Raumtypen einteilt, um statistische Analysen zu ermöglichen.\nDie Urban-Rural Typologie der Statistik Austria kann im STATAtlas heruntergeladen werden: https://www.statistik.at/atlas/?mapid=topo_regionale_gliederung_oesterreich\n\ntyp &lt;- read.csv2(\"data/003_gliederungen_nach_städtischen_und_ländlichen_gebieten(1).csv\")\n\nhead(typ)\n\n  gemnr                           Name Wert\n1 10101                     Eisenstadt  103\n2 10201                           Rust  410\n3 10301 Breitenbrunn am Neusiedler See  310\n4 10302                 Donnerskirchen  310\n5 10303                    Großhöflein  103\n6 10304                      Hornstein  310",
    "crumbs": [
      "Skript 2 - Daten import, manipulation & plotten"
    ]
  },
  {
    "objectID": "01_basics.html",
    "href": "01_basics.html",
    "title": "Skript 1 - R/RStudio Basics",
    "section": "",
    "text": "1.1. Was ist R?\nR ist eine kostenlose Open-Source-Programmiersprache, die für Datenanalyse, Statistik und Visualisierung entwickelt wurde.\n\n\n1.2. Was ist RStudio?\nRStudio ist eine integrierte Entwicklungsumgebung (IDE) für R, die eine benutzerfreundliche Oberfläche zum Schreiben von Code, Verwalten von Dateien, Visualisieren von Daten und effizienten Organisieren von Projekten bietet.\n\n\n1.3. Wie ist RStudio aufgebaut?\n–&gt; “4 Quadranten”\n\n\n\n1.4. Objekte und Zuweisung\nR ist eine objektorientierte Sprache. Alles ist ein Objekt. Eine Zahl, eine Tabelle, ein Diagramm – alles Objekte. Objekte werden mit dem Zuweisungsoperator &lt;- erstellt.\nMit Strg + Enter können wir Code-Zeilen in der Console ausführen.\n\n# Erstelle ein Objekt \"x\" \nx &lt;- 10 \n# Rechne mit dem Objekt \nx + 5\n\n[1] 15\n\n\n\n\n1.5. Vektoren\nEin Vektor ist eine Liste von Dingen. Verwende c() (kombinieren), um eine Liste zu erstellen.\n\nmy_ages &lt;- c(25,24,30,50) \nmy_names &lt;- c(\"Sandra\", \"Paul\", \"Jonas\")\n\nBei der Berechnung eines Vektors wird dies für jedes Element gleichzeitig durchgeführt.\n\nmy_ages + 2\n\n[1] 27 26 32 52\n\n\n\n\n1.6. Datentypen\nR muss wissen, um welche Art von Daten es sich handelt. Mathematische Berechnungen mit einem Wort führen zu einem Error.\n\n\n\nTyp\nBeschreibung\nBeispiel\n\n\n\n\nNumeric (dbl)\nNummer mit Dezimalstellen\n1.5; 200\n\n\nInteger (int)\nGanze Zahlen\n5\n\n\nCharacter (chr)\nText. Immer in “”\n“Hello”\n\n\nLogical (lgl)\nTRUE or FALSE. Boolean\nTRUE, FALSE\n\n\nFactor (fct)\nKategorien (Nominal/Ordinal)\n“High”, “Low”\n\n\n\n\nclass(my_ages) \n\n[1] \"numeric\"\n\nclass(my_names) \n\n[1] \"character\"\n\n# my_names + 5\n\n\n\n1.7. Dataframes\nDies ist die” Excel-Tabelle” von R. Ein Datenrahmen ist zweidimensional: Zeilen (Beobachtungen) und Spalten (Variablen). Hier finden 99 % der Datenanalysen statt.\n\n\n\nid\nname\nscore\n\n\n\n\n1\n“A”\n90\n\n\n2\n“B”\n75\n\n\n3\n“C”\n80\n\n\n4\n“D”\n84\n\n\n5\n“E”\n95\n\n\n\n\ndf &lt;- data.frame(id = c(1,2,3,4,5),   \n                 name = c(\"A\", \"B\", \"C\", \"D\", \"E\"),   \n                 score = c(90, 75, 80, 84, 95) )\n\nDer Dollarzeichen-Operator $ wird verwendet, um eine einzelne Spalte aus einem Datenrahmen auszuwählen. “df$score” bedeutet also: „Gehe zum Datenrahmen „df“ UND wähle die Spalte „score“ aus.\nMit der Funktion mean() können wir Mittelwerte von Vektoren berechnen.\n\ndf$score \n\n[1] 90 75 80 84 95\n\nmean(df$score)\n\n[1] 84.8\n\n\nBenutze str() um eine Zusammenfassung des dataframes auszugeben.\n\nstr(df)\n\n'data.frame':   5 obs. of  3 variables:\n $ id   : num  1 2 3 4 5\n $ name : chr  \"A\" \"B\" \"C\" \"D\" ...\n $ score: num  90 75 80 84 95\n\n\n\n\n1.8. Packages\nPackages sind Tools (oder kleine “Software”) die in R für bestimmte Anwendungen geschrieben worden sind. Zum Beispiel wird das Package “ggplot” häufig für Visualisierungen verwendet. Das wichtigste Package-Bundle ist “tidyverse”.\nGenerell können wir Pakete mit install.packages() installieren. Um ein bereits installiertes Paket zu laden und in unserem Skript verwenden zu können benutzen wir library().\n\n#install.packages(\"tidyverse\") \nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDas Tidyverse ist eine Sammlung aufeinander abgestimmter R-Pakete, die eine einheitliche und leicht verständliche Grammatik zum Importieren, Aufräumen, Transformieren und Visualisieren von Daten bereitstellen (im Gegensatz zu base-R).\nBei Error “Kein package namens…” -&gt; vergessen das Package mit library() zu laden.\nBeispiele für wichtige und häufig verwendete Packages aus dem Tidyverse-Bundle sind ggplot (Visualisierung) dplyr (Data Manipulation, filter, select, summarize), tidyr (data reshaping) oder readr (schneller daten import)",
    "crumbs": [
      "Skript 1 - R/RStudio Basics"
    ]
  },
  {
    "objectID": "03_sequenzanalyse.html",
    "href": "03_sequenzanalyse.html",
    "title": "Skript 3 - Sequenzanalyse",
    "section": "",
    "text": "3.1. Was ist Sequenzanalyse?\nDie Sequenzanalyse ist eine Methode zur Untersuchung von Abfolgen kategorialer Zustände über die Zeit. Im Unterschied zu klassischen statistischen Ansätzen betrachtet sie nicht nur, welche Ereignisse auftreten, sondern auch in welcher Reihenfolge und Dauer sie stattfinden. Dadurch lassen sich typische Verlaufsformen – etwa von Bildungs-, Erwerbs- oder Mobilitätsbiographien – sichtbar machen und miteinander vergleichen. Ebenfalls können kategorisierte Bevölkerungsveränderungen zwischen statistischen Einheiten verglichen werden.\nTypische Fragestellungen, bei denen eine Sequenzanalyse sinnvoll sein kann:\nWelche typischen Verlaufsformen lassen sich in den Daten erkennen, und wie unterscheiden sich diese zwischen statistischen Einheiten? Können darin typische Verlaufsmuster erkannt werden?\n\n\n3.2. Was ist eine Sequenz?\nEine Sequenz ist eine geordnete Folge von Zuständen oder Ereignissen, die eine Einheit (z. B. eine Person oder Gemeinde) über mehrere Zeitpunkte hinweg durchläuft.\n\nIn diesem Beispiel wären x1, x3, x4 Zustände. Die statistische Einheit (observation) durchläuft diese Zustände im Zeitverlauf.\n\n\n3.3. Kategorisierung von Bevölkerungsveränderungsraten\nZiel in diesem Skript-Abschnitt ist es, die Bevölkerungsveränderungsraten auf Gemeindeebene zu kategorisieren und deren Ablauf mittels einer Sequenzanalyse zu vergleichen.\nWir berechnen zunächst erneut die jährliche Bevölkerungsveränderungsrate, diesmal für jede Gemeinde. Da die Raten auf Gemeindebene sehr stark fluktuieren können (zB. Eröffnung eines Pflegeheimes) verwenden wir einen rollenden Mittelwert als “smoothing” Technik.\nDie Tabelle wird nach Gemeinde und Jahr sortiert, und mit rollapply() wird für jede Gemeinde ein 3-Jahres-Rolling Mean der Bevölkerungsraten berechnet (rate_roll3), wobei die Mittelwerte jeweils die aktuellen und zwei vorhergehenden Jahre umfassen (align = \"right\"). Am Ende werden noch fehlende Werte entfernt und die Daten wieder entgruppiert, sodass die rollenden Mittelwerte bereit für die Kategorisierung sind.\n\nseq_dta &lt;- dta %&gt;% \n  group_by(gemnr) %&gt;% \n  mutate(pop_diff = pop - lag(pop),\n         pop_rate = (pop_diff / lag(pop)) * 100) %&gt;% \n  ungroup() %&gt;% \n  select(jahr, gemnr, pop_rate, bld) %&gt;% \n  drop_na()\n\nlibrary(zoo)\n\n\nAttache Paket: 'zoo'\n\n\nDie folgenden Objekte sind maskiert von 'package:base':\n\n    as.Date, as.Date.numeric\n\nseq_dta &lt;- seq_dta %&gt;% \n  arrange(gemnr, jahr) %&gt;% \n  group_by(gemnr) %&gt;% \n  mutate(rate_roll3 = rollapply(pop_rate,\n                                width = 3,\n                                FUN = mean,\n                                fill = NA,\n                                align = \"right\")) %&gt;% \n  drop_na() %&gt;% \n  ungroup()\n\nDer Code teilt die zuvor berechneten 3-Jahres-Rolling Means der Bevölkerungsraten (rate_roll3) in vier Kategorien ein. Mit ntile(..., 4) werden die Werte in Quartile unterteilt, sodass jede Kategorie etwa ein Viertel der Daten enthält. Anschließend werden die numerischen Quartile in lesbare Labels umgewandelt (stark negativ bis stark positiv), sodass die Ergebnisse leichter interpretierbar und für Visualisierungen nutzbar sind.\nMit table(seq_dta$rate_quartile) wird schließlich die Häufigkeitsverteilung der Kategorien angezeigt, sodass man schnell sehen kann, wie viele Beobachtungen in jede Gruppe fallen.\n\nsummary(seq_dta$rate_roll3)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-16.1922  -0.3777   0.2104   0.2639   0.8357  14.0328 \n\nseq_dta &lt;- seq_dta %&gt;%\n  mutate(rate_quartile = ntile(rate_roll3, 4),\n         rate_quartile = factor(rate_quartile,\n           levels = 1:4,\n           labels = c(\"stark negativ\", \"negativ\", \"positiv\", \"stark positiv\")\n         ))\n\ntable(seq_dta$rate_quartile)\n\n\nstark negativ       negativ       positiv stark positiv \n        10042         10042         10041         10041 \n\n\n\nseq &lt;- seq_dta %&gt;% \n  pivot_wider(id_cols = c(gemnr, bld),\n              names_from = jahr,\n              values_from = rate_quartile)\n\nseq &lt;- left_join(seq, typ, by = \"gemnr\")\nseq$Wert[is.na(seq$Wert)] &lt;- \"101\"\n\nDer folgende Code erstellt eine Sequenzanalyse für die Spalten 3 bis 21 im Datensatz seq, die beispielsweise jährliche Veränderungen oder Ratings abbilden. Zunächst werden die Zustände der Sequenzen definiert: seq.scode kodiert sie intern als \"HG\", \"G\", \"D\" und \"HD\", während seq.alphabet und seq.labels für die lesbaren Bezeichnungen sorgen („stark positiv“ bis „stark negativ“). Mit seqdef() werden die Daten als Sequenzen vorbereitet, inklusive Farben für die Visualisierung (seq.cpal1), sodass jeder Zustand konsistent dargestellt wird.\nAnschließend erlaubt der Code eine erste Exploration der Sequenzen: seqstatl() zeigt die Häufigkeit der Zustände über die Zeit, print() und summary() geben Übersicht über die Sequenzen einzelner Gemeinden und deren statistische Zusammenfassung, und seqlegend() erzeugt eine Legende, die die Farben den Zuständen zuordnet. So können Studierende schnell sehen, wie sich Zustände über die Zeit verteilen und Muster in den Sequenzen erkennen.\n\nseqstatl(seq[, 3:21])\n\n[1] \"negativ\"       \"positiv\"       \"stark negativ\" \"stark positiv\"\n\nseq.alphabet &lt;- c(\"stark positiv\", \"positiv\", \"negativ\", \"stark negativ\")\nseq.labels &lt;- seq.alphabet\nseq.scode &lt;- c(\"HG\", \"G\", \"D\", \"HD\")\nseq.cpal1= c(\"#d7191c\",\"#fec980\", \"#c7e6db\", \"#2c7bb6\") \nseq.df &lt;- seqdef (seq, var= 3:21, \n                  states=seq.scode, \n                  labels=seq.labels, \n                  alphabet=seq.alphabet, \n                  cpal = seq.cpal1)\n\n [&gt;] state coding:\n\n\n       [alphabet]    [label]  [long label] \n\n\n     1  stark positiv HG       stark positiv\n\n\n     2  positiv       G        positiv\n\n\n     3  negativ       D        negativ\n\n\n     4  stark negativ HD       stark negativ\n\n\n [&gt;] 2114 sequences in the data set\n\n\n [&gt;] min/max sequence length: 19/19\n\nprint(seq.df[1:5, ], format=\"SPS\")\n\n  Sequence                                                                          \n1 (HG,19)                                                                           \n2 (HG,3)-(G,1)-(HG,3)-(G,2)-(HG,1)-(G,1)-(D,1)-(HD,1)-(D,1)-(G,1)-(HG,2)-(G,1)-(D,1)\n3 (G,3)-(HG,5)-(G,2)-(D,2)-(G,2)-(D,1)-(HD,2)-(D,1)-(HG,1)                          \n4 (HG,3)-(G,2)-(D,2)-(G,3)-(D,1)-(G,1)-(HG,3)-(G,3)-(D,1)                           \n5 (D,1)-(G,3)-(D,1)-(HG,7)-(G,1)-(D,1)-(G,2)-(HG,1)-(G,1)-(D,1)                     \n\nsummary(seq.df)\n\n [&gt;] sequence object created with TraMineR version 2.2-8 \n [&gt;] 2114 sequences in the data set, 2072 unique \n [&gt;] min/max sequence length: 19/19\n [&gt;] alphabet (state labels):  \n     1=HG (stark positiv)\n     2=G (positiv)\n     3=D (negativ)\n     4=HD (stark negativ)\n [&gt;] dimensionality of the sequence space: 57 \n [&gt;] colors: 1=#d7191c 2=#fec980 3=#c7e6db 4=#2c7bb6 \n\nseqlegend(seq.df)\n\n\n\n\n\n\n\n\n\nseqiplot(seq.df, border=NA, idxs= 1:2114)\n\n\n\n\n\n\n\nseqdplot(seq.df, main = \"Sequence distribution plot\", border=T) \n\n\n\n\n\n\n\nseqiplot(seq.df, border=NA, group = seq$Wert, idxs= 1:2114)\n\n\n\n\n\n\n\nseqdplot(seq.df, main = \"Sequence distribution plot\", group = seq$Wert, border=T) \n\n\n\n\n\n\n\nseqfplot(seq.df, main = \"Sequence frequency plot\", group = seq$Wert, border=T) \n\n\n\n\n\n\n\n\n\n\n3.4. Berechnung von Distanzmaßen mit Optimal Matching\nOptimal Matching (OM) ist eine Methode der Sequenzanalyse, die die Ähnlichkeit zwischen zeitlich geordneten Ereignisfolgen misst.\nKonkret vergleicht OM zwei Sequenzen, indem es die minimale „Bearbeitungskosten“-Summe berechnet, die nötig ist, um die eine Sequenz in die andere zu überführen. Dabei werden drei Arten von Operationen erlaubt:\n\nInsertion – Einfügen eines Zustands\nDeletion – Löschen eines Zustans\nSubstitution – Ersetzen eines Zustands durch einen anderen\n\nJede Operation wird mit einer Kostenfunktion versehen, sodass Sequenzen, die ähnlich verlaufen, geringere Gesamtkosten haben. Die resultierende Distanzmatrix kann anschließend für Clusteranalysen, Multidimensionale Skalierung (MDS) oder Visualisierung von Sequenzmustern verwendet werden.\nOM quantifiziert, wie „nah“ zwei zeitliche Abläufe beieinanderliegen, und erlaubt so die Analyse von typischen Mustern und Abweichungen in Sequenzdaten.\n\ncosts &lt;- seqcost(seq.df, method = \"INDELSLOG\")\ndist.om &lt;- seqdist(seq.df, method = \"OM\", indel = costs$indel, sm = costs$sm)\n\n [&gt;] 2114 sequences with 4 distinct states\n\n\n [&gt;] checking 'sm' (size and triangle inequality)\n\n\n [&gt;] 2072 distinct  sequences \n\n\n [&gt;] min/max sequence lengths: 19/19\n\n\n [&gt;] computing distances using the OM metric\n\n\n [&gt;] elapsed time: 3.99 secs\n\n\n\n\n3.5. Clustering\nClustering ist ein Verfahren, bei dem Beobachtungen in Gruppen (Cluster) eingeteilt werden, sodass die Objekte innerhalb eines Clusters möglichst ähnlich und zwischen Clustern möglichst unterschiedlich sind.\nWard’s Methode ist eine spezielle Form des hierarchischen Clustering. Sie arbeitet nach dem Prinzip, dass in jedem Schritt die beiden Cluster zusammengeführt werden, deren Zusammenfassung die geringste Zunahme der Gesamtsumme der quadrierten Abweichungen (Within-Cluster-Variance) verursacht. Anders gesagt: Ward sucht immer die Kombination, die die homogensten Gruppen erzeugt.\nTendenziell erzeugt dieser Clustering-Algorithmus ähnlich große und kompakte Cluster, was die Interpretation von Gruppenmustern erleichtert.\n\nwardcluster_OM &lt;- hclust(as.dist(dist.om), method = \"ward.D\")\nk &lt;- 6\ngroups.om &lt;- cutree(wardcluster_OM, k = k)\nseqiplot(seq.df, border=NA, group = groups.om, idxs= 1:2114)\n\n\n\n\n\n\n\nseqdplot(seq.df, main = \"Sequence distribution plot\", group = groups.om, border=T) \n\n\n\n\n\n\n\nseqfplot(seq.df, main = \"Sequence frequency plot\", group = groups.om, border=T) \n\n\n\n\n\n\n\n\n\n\n3.6. Bonus: Dynamic Hamming Distance\n\n#?seqdist\ncosts &lt;- seqcost(seq.df, method = \"INDELSLOG\")\ndist.dhd &lt;- seqdist(seq.df, method = \"DHD\", indel = costs$indel)\n\n [&gt;] 2114 sequences with 4 distinct states\n\n\n [&gt;] creating a 'sm' with the costs derived from the transition rates\n\n\n [&gt;] creating time varying substitution-cost matrix using transition rates ...\n\n\n [&gt;] computing time varying transition probabilities for states HG/G/D/HD ...\n\n\n [&gt;] 2072 distinct  sequences \n\n\n [&gt;] min/max sequence lengths: 19/19\n\n\n [&gt;] computing distances using the DHD metric\n\n\n [&gt;] elapsed time: 0.18 secs\n\nwardcluster_DHD &lt;- hclust(as.dist(dist.dhd), method = \"ward.D\")\n\nk &lt;- 6\ngroups.dhd &lt;- cutree(wardcluster_DHD, k = k)\n\n\nseqiplot(seq.df, border=NA, group = groups.dhd, idxs= 1:2114)\n\n\n\n\n\n\n\nseqdplot(seq.df, main = \"Sequence distribution plot\", group = groups.dhd, border=T) \n\n\n\n\n\n\n\nseqfplot(seq.df, main = \"Sequence frequency plot\", group = groups.dhd, border=T) \n\n\n\n\n\n\n\n\n\nseq$cluster.om &lt;- factor(groups.om)\nseq$cluster.dhd &lt;- factor(groups.dhd)\n\nwrite.csv(seq, \"data/Sequenzdaten.csv\")",
    "crumbs": [
      "Skript 3 - Sequenzanalyse"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]